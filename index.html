<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"iwefwkg.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://iwefwkg.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="mxm">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://iwefwkg.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">mxm</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://iwefwkg.github.io/2023/03/14/http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mxm">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/14/http/" class="post-title-link" itemprop="url">http</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-03-14 20:29:17" itemprop="dateCreated datePublished" datetime="2023-03-14T20:29:17+08:00">2023-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-04-09 22:04:08" itemprop="dateModified" datetime="2023-04-09T22:04:08+08:00">2023-04-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简单的HTTP协议"><a href="#简单的HTTP协议" class="headerlink" title="简单的HTTP协议"></a>简单的HTTP协议</h1><h2 id="HTTP协议用于客户端和服务器之间的通信"><a href="#HTTP协议用于客户端和服务器之间的通信" class="headerlink" title="HTTP协议用于客户端和服务器之间的通信"></a>HTTP协议用于客户端和服务器之间的通信</h2><p>HTTP和TCP&#x2F;IP协议族内的其他协议相同，用以客户端和服务器之间的通信。 客户端与服务器端的角色由可能会互换，但就从一条通信路线来说，服务器端与客户端的角色是确定的，HTTP协议能够区分哪端是客户端与服务器端。</p>
<h2 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h2><p>由客户端向服务器发送请求报文，服务器传回响应报文。<br>请求报文由请求方法，请求URI，协议版本，可选的请求首部字段和实体内容组成。<br>响应报文基本上由协议版本，状态码（表示请求成功或失败的数字代码），用以解释状态码的原因短语，可选的响应首部字段以及实体主体构成。</p>
<h2 id="HTTP是不保存状态的协议"><a href="#HTTP是不保存状态的协议" class="headerlink" title="HTTP是不保存状态的协议"></a>HTTP是不保存状态的协议</h2><p>HTTP是一种不保存状态，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对发送过的请求和相应的响应都不做持久化处理。这是为了更快的处理大量事务，确保协议的可伸缩性。<br>后来随着Web的不断发展，无状态而导致业务处理变得棘手的情况也变多了，为了实现期望的保持状态功能，引入了Cookie技术以管理状态。</p>
<h2 id="请求URI定位资源"><a href="#请求URI定位资源" class="headerlink" title="请求URI定位资源"></a>请求URI定位资源</h2><p>HTTP协议用URI使客户端定位互联网上的资源，请求URI的方式有很多种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://hackr.jp/index.htm HTTP/1.1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.htm HTTP/1.1</span><br><span class="line">Host: hackr.jp</span><br></pre></td></tr></table></figure>
<h2 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>支持的HTTP版本</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取资源</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>POST</td>
<td>传输实体主体</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>PUT</td>
<td>传输文件</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>HEAD</td>
<td>获得报文首部</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>询问支持的方法</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>TRACE</td>
<td>追踪路径</td>
<td>1.1</td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求用隧道协议连接代理</td>
<td>1.1</td>
</tr>
</tbody></table>
<h3 id="GET-获取资源"><a href="#GET-获取资源" class="headerlink" title="GET:获取资源"></a>GET:获取资源</h3><p>GET 方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容，如果是文本保持原样返回；如果是像CGI（通用网关接口）那样的程序，则返回执行后的输出结果。</p>
<table>
<thead>
<tr>
<th>请求</th>
<th>GET&#x2F;index.html HTTP&#x2F;1.1<br> Host:<a target="_blank" rel="noopener" href="http://www.hackr.jp/">www.hackr.jp</a></th>
</tr>
</thead>
<tbody><tr>
<td>响应</td>
<td>返回index.html的页面资源</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>请求</th>
<th>GET&#x2F;index.html HTTP&#x2F;1.1<br> Host:<a target="_blank" rel="noopener" href="http://www.hackr.jp/">www.hackr.jp</a> <br> if-Modified-Since:Thu,12 Jul 2012 7:30:00 GMT</th>
</tr>
</thead>
<tbody><tr>
<td>响应</td>
<td>仅返回2012年7月12日7点30分以后更新过的index.html页面资源。如果未有内容更新，则以304状态码返回</td>
</tr>
</tbody></table>
<h3 id="POST：传输实体主体"><a href="#POST：传输实体主体" class="headerlink" title="POST：传输实体主体"></a>POST：传输实体主体</h3><p>用来传输实体的主体，主要目的不是获取响应的主体内容</p>
<table>
<thead>
<tr>
<th>请求</th>
<th>POST&#x2F;submit.cgi HTTP&#x2F;1.1 <br> Host:<a target="_blank" rel="noopener" href="http://www.hackr.jp/">www.hackr.jp</a><br>  Content-Length: 1560</th>
</tr>
</thead>
<tbody><tr>
<td>响应</td>
<td>返回submit.cgi接收数据的处理结果</td>
</tr>
</tbody></table>
<h3 id="PUT-传输文件"><a href="#PUT-传输文件" class="headerlink" title="PUT:传输文件"></a>PUT:传输文件</h3><p>PUT方法用来传输文件，就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到URI指定的位置。<br>但是HTTP&#x2F;1.1的put方法不带验证机制，任何人都可以上传文件，存在安全问题，因此一般web网站不用该方法。配合Web应用程序的验证机制，或架构设计采用REST（表征状态转移）标准的同类web网站，就会开放PUT方法。</p>
<h3 id="HEAD-获取报文首部"><a href="#HEAD-获取报文首部" class="headerlink" title="HEAD:获取报文首部"></a>HEAD:获取报文首部</h3><p>HEAD方法和GET方法一致，只是不返回报文主体，用以确认URI的有效性以及资源更新的日期时间等。</p>
<h3 id="DELETE-删除文件"><a href="#DELETE-删除文件" class="headerlink" title="DELETE:删除文件"></a>DELETE:删除文件</h3><p>DELETE方法用来删除文件，按请求URI删除指定的资源。在HTTP&#x2F;1.1中和PUT一样不带验证机制。</p>
<h3 id="OPTIONS：询问支持的方法"><a href="#OPTIONS：询问支持的方法" class="headerlink" title="OPTIONS：询问支持的方法"></a>OPTIONS：询问支持的方法</h3><p>用来查询针对请求URI指定的资源支持的方法</p>
<h3 id="TRACE：追踪路径"><a href="#TRACE：追踪路径" class="headerlink" title="TRACE：追踪路径"></a>TRACE：追踪路径</h3><p>让web服务器端将之前的请求通信返回给客户端。<br>发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK的响应。<br>客户端可以通过该方法查询发送出去的请求是如何被加工修改&#x2F;篡改的。<br>TRACE方法容易引发XST（跨站追踪）攻击，通常不会用到。</p>
<table>
<thead>
<tr>
<th>请求</th>
<th>TRACE&#x2F;HTTP&#x2F;1.1 <br> Host:hackr.jp <br> Max-Forwards:2</th>
</tr>
</thead>
<tbody><tr>
<td>响应</td>
<td>HTTP&#x2F;1.1 200 OK<br> Content-Type：message&#x2F;http<br> content-Length:1024 <br> TRACE&#x2F;HTTP&#x2F;1.1  <br>Host:hackr.jp <br> Max-Forwards:2</td>
</tr>
</tbody></table>
<h3 id="CONNECT-要求用隧道协议连接代理"><a href="#CONNECT-要求用隧道协议连接代理" class="headerlink" title="CONNECT:要求用隧道协议连接代理"></a>CONNECT:要求用隧道协议连接代理</h3><p>要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（安全套接层）和 TLS（传输层安全）协议把通信内容加密后经网络隧道传输。<br>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONNECT 代理服务器名 : 端口号 HTTP版本</span><br></pre></td></tr></table></figure>
<h2 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h2><p>HTTP协议的初始版本，没进行一次HTTP通信就要断开一次TCP连接，因此每次的请求都会造成无谓的TCP建立与断开，增加通信量的开销。</p>
<ol>
<li>持久连接<br>持久连接的特点只要一端没有明确提出断开连则保持TCP连接状态。<br>持久连接的好处减少了TCP连接的重复建立与断开所造成的额外开销，使HTTP请求和响应加快，使web页面更快显示。</li>
<li>管线化<br>能够同时并行发送多个请求，加快请求的结束。不用等待响应，就能之间发送下一个请求。</li>
</ol>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>HTTP是无状态协议，他不对之前发生过的请求和响应进行管理，也就是无法根据之前的状态进行本次的请求处理。<br>例如要求登录认证的web界面无法进行状态管理，那么每次跳转新的界面都要再次登录或者要求每次在请求报文中附加参数来管理登录状态。<br>Cookie会根据从服务器发送的响应报文内一个叫做Set-Cookie的首部字段信息，通知客户端保存cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中添加cookie值后发送出去。服务器发现客户端发送过来的连接请求，然后对比服务器上的记录，最后得到之前的信息。</p>
<h1 id="HTTP报文内的HTTP信息"><a href="#HTTP报文内的HTTP信息" class="headerlink" title="HTTP报文内的HTTP信息"></a>HTTP报文内的HTTP信息</h1><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>请求端（客户端）的请求报文称作请求报文，响应端的叫做响应报文。HTTP报文大致可分为报文首部和报文主体，两者由最初出现的空行（CR+LF）划分。</p>
<h3 id="报文首部"><a href="#报文首部" class="headerlink" title="报文首部"></a>报文首部</h3><p>服务器端或客户端吧需处理的请求或响应的内容及原理。<br>请求报文<br>请求行，请求首部字段，通用首部字段与实体首部字段组成。<br>响应报文<br>状态行，响应首部字段，通用首部字段与实体首部字段组成。</p>
<h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>包含用于请求的方法，请求URI和HTTP版本。</p>
<h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><p>包含表明响应结果的状态吗，原因短语和HTTP版本。</p>
<h4 id="首部字段"><a href="#首部字段" class="headerlink" title="首部字段"></a>首部字段</h4><p>包含表明请求和相应的各种条件和属性的各类首部。</p>
<h2 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h2><p>HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效处理大量的访问请求。</p>
<h3 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h3><h4 id="报文主体"><a href="#报文主体" class="headerlink" title="报文主体"></a>报文主体</h4><p>是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输。<br>HTTP的报文主体用于传输 请求或响应的实体主体。</p>
<h4 id="实体主体"><a href="#实体主体" class="headerlink" title="实体主体"></a>实体主体</h4><p>作为请求或响应的有效载荷（补充项）被传输，其内容由实体首部和实体主体组成。<br>通常报文主体等于实体主体，在传输中进行编码操作时，实体主体的内容发生变化，两者产生差异。</p>
<h3 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h3><p>HTTP协议中有一种被称作内容编码的功能可以压缩数据。内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩，内容编码后的实体由客户端接收并负责解码。<br>常用的内容编码：<br>*gzip（GNU zip）<br>*compress（unix系统的标准压缩）<br>*deflate（zlib）<br>*identity（不进行编码）</p>
<h3 id="分割传送的分块传输编码"><a href="#分割传送的分块传输编码" class="headerlink" title="分割传送的分块传输编码"></a>分割传送的分块传输编码</h3><p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时可以把数据分割成多块，能够让浏览器逐步显示页面。<br>分块传输编码会将实体主体部分分成多个块。每一块都会用十六进制来标记块的大小，实体的最后一块会使用“0（CR+LF）”标记。分块编码的实体主体由接受的客户端解码，恢复到编码前的实体主体。<br>HTTP中存在一种传输编码的机制，可以在通信时以某种编码方式传输，只定义作用于分块传输编码中。</p>
<h2 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h2><p>发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了MIME（多用途因特网邮件扩展）机制，它允许邮件处理多个不同类型的数据。例如：图片等二进制数据以ASCII码字符串编码的方式指明，就是利用MIME来描述标记数据类型。而在MIME扩展中会使用一种称为多部分对象集合的办法，来容纳多份不同类型的数据。<br>HTTP协议也采纳了多部分对象集合，如下：</p>
<h4 id="multiparty-x2F-form-data"><a href="#multiparty-x2F-form-data" class="headerlink" title="multiparty&#x2F;form-data"></a>multiparty&#x2F;form-data</h4><p>在web表单文件上传时使用、</p>
<h4 id="multiparty-x2F-byteranges"><a href="#multiparty-x2F-byteranges" class="headerlink" title="multiparty&#x2F;byteranges"></a>multiparty&#x2F;byteranges</h4><p>状态码206响应报文包含了多个范围的内容使用</p>
<p>在HTTP报文使用多部分对象集合时，需要在首部字段里加上Content-type。<br>多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可以在某个部分嵌套使用多部分对象集合。</p>
<h2 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h2><p>为了解决下载过程中避免遇到网络中断，而从头开始的情况，HTTP使用了一种可以从之前下载中断处恢复下载的机制。<br>执行范围请求时，会用到首部字段range来指定资源的byte范围。byte范围形式如下：<br>5001-10000：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range：bytes=5001-10000</span><br></pre></td></tr></table></figure>
<p>5001到后面全部：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range：bytes=5001-</span><br></pre></td></tr></table></figure>
<p>从一开始到3000，5000到7000：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range：bytes=1-3000，5000-7000</span><br></pre></td></tr></table></figure>
<p>针对范围请求，响应会返回状态码为206 Partial Content的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type标明multiparty&#x2F;byteranges后返回响应报文。<br>如果服务器无法响应范围请求，则会返回状态码200 OK和完整的实体内容。</p>
<h2 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h2><p>当浏览器的默认语言为英文或中文，访问相同的URI的web页面时，则会显示对应的英语或中文版的web页面。这样的机制称为内容协商。内容协商会以语言、字符集、编码方式等为基准判断响应的资源。有以下三种类型：</p>
<ol>
<li>服务器驱动协商<br>由服务器端进行内容协商，以请求的首部字段为参考，在服务器端自动处理。以浏览器发送的信息作为判定的依据。</li>
<li>客户端驱动协商<br>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用JavaScript脚本在web页面上自动进行选择。比如按OS的类型或浏览器的类型，自动切换成PC版页面或手机版页面。</li>
<li>透明协商<br>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方式。</li>
</ol>
<h1 id="返回结果的HTTP状态码"><a href="#返回结果的HTTP状态码" class="headerlink" title="返回结果的HTTP状态码"></a>返回结果的HTTP状态码</h1><p>HTTP状态码负责表示客户端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。</p>
<h2 id="状态码告知从服务器端返回的请求结果"><a href="#状态码告知从服务器端返回的请求结果" class="headerlink" title="状态码告知从服务器端返回的请求结果"></a>状态码告知从服务器端返回的请求结果</h2><p>状态码是客户端向服务器发送请求时，描述返回的请求结果。<br>状态码如200 OK，以3位数字和原因短语组成。<br>数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">类别</th>
<th align="center">原因短语</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1××</td>
<td align="center">informational（信息性状态码）</td>
<td align="center">接受的请求正在处理</td>
</tr>
<tr>
<td align="center">2××</td>
<td align="center">success（成功状态码）</td>
<td align="center">请求正常处理完毕</td>
</tr>
<tr>
<td align="center">3××</td>
<td align="center">Redirection（重定向状态码）</td>
<td align="center">需要进行附加操作以作完成请求</td>
</tr>
<tr>
<td align="center">4××</td>
<td align="center">client error（客户端错误状态吗）</td>
<td align="center">服务器无法处理请求</td>
</tr>
<tr>
<td align="center">5××</td>
<td align="center">serve error（服务器错误状态码）</td>
<td align="center">服务器处理请求出错</td>
</tr>
</tbody></table>
<h3 id="2××-成功"><a href="#2××-成功" class="headerlink" title="2×× 成功"></a>2×× 成功</h3><p>2xx的响应结果表明请求被正常处理了。</p>
<ol>
<li>200 OK<br>表示从客户端发来的请求在服务器端被正常处理了。<br>在响应报文内，随状态码一起返回的信息因方法的不同而改变。比如：使用GET方法时，对应请求资源的实体会作为响应返回；而使用HEAD方法时，对应请求资源的实体主体不随报文首部作为相应返回（即在响应中只返回首部，不会返回实体的主体部分）。</li>
<li>204 No Content<br>表示请求成功处理，但在返回的响应报文中不含实体的主体部分，也不允许返回任何实体的主体。一般在只需要客户端往服务器发送信息，对客户端不需要发送新信息与内容的情况下使用</li>
<li>206 Partial Content<br>该状态码表示客户端进行了范围请求，而且服务器成功执行这部分的GET请求。响应报文中包含content-range指定范围的实体内容。</li>
</ol>
<h3 id="3xx重定向"><a href="#3xx重定向" class="headerlink" title="3xx重定向"></a>3xx重定向</h3><p>3xx响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<ol>
<li>301 Moved Permanently<br>永久性重定向。该状态码表示请求的资源已被分配了新的URI，应使用资源现在所指的URI。也就是说，如果已经把资源对应的URI保存为书签了，这时应该按location首部字段提示的URI重新保存。</li>
<li>302 Found<br>临时重定向。该状态码表示请求的资源已经被分配了新的URI，希望用户能使用新的URI访问。<br>和301 Moved Permanently 状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的，已经移动的资源对应URI将来还有可能发生改变。比如：用户把URI保存成书签，不会像301状态码那样，在出现时去更新书签，而是仍保留返回302状态码页面对应的URI</li>
<li>303 see other<br>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。303状态码和302 Found状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，与302状态码有区别。</li>
<li>304 Not Modified<br>表示客户端发送<strong>附带条件的请求</strong>（指采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部），服务器端允许访问资源，但未符合条件请求，直接返回304状态码，304状态码返回时不包含任何响应的主体部分。</li>
<li>307 Temporary Redirect<br>临时重定向，与302 Found有着相同的含义。307会遵照浏览器标准，不会从POST变成GET。</li>
</ol>
<h2 id="4xx客户端错误"><a href="#4xx客户端错误" class="headerlink" title="4xx客户端错误"></a>4xx客户端错误</h2><p>4xx的响应结果表明客户端是发生错误的原因所在</p>
<ol>
<li>400 Bad Request<br>表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。</li>
<li>401 Unauthorized<br>该状态码表示发送的请求需要有通过HTTP认证的认证信息。返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询用户信息。当浏览器<strong>初次</strong>接收到401响应，会弹出认证用的对话窗口。</li>
<li>403 Forbidden<br>表示对资源的访问被服务器拒绝了。<br>如果想对拒绝理由进行说明，可以在实体的主体部分对原因进行描述。<br>未获得文件系统的访问授权，访问权限出现了某些问题等情况都可能发生403.</li>
<li>404 Not Found<br>该状态码表示服务器上无法找到请求的资源；也可以在服务器端拒绝请求时，且不想说明理由时使用。</li>
</ol>
<h2 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx 服务器错误"></a>5xx 服务器错误</h2><p>5xx表明服务器本身发生错误</p>
<ol>
<li>500 Internal Serve Error<br>表明服务器端在执行请求时发生错误；web应用存在的bug或某些临时的故障</li>
<li>503 Service Unavailable<br>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果已经知道解除上述状况所需时间，可以写入Retry-After首部字段再返回给客户端。</li>
</ol>
<h1 id="与HTTP协作的Web服务器"><a href="#与HTTP协作的Web服务器" class="headerlink" title="与HTTP协作的Web服务器"></a>与HTTP协作的Web服务器</h1><p>一台Web服务器可以搭建多个独立域名的Web网站，也可以作为通信路径上的中转服务器提升传输效率。</p>
<h2 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h2><p>HTTP&#x2F;1.1规范允许一台HTTP服务器搭建多个Web站点，即物理层面只有一台服务器，但使用虚拟主机功能，可以假想有多台服务器。<br>在互联网上，域名通过DNS服务映射到IP地址（域名解析）之后访问的目标网站，可见当请求发送到服务器时，已经是以IP地址的形式访问了。<br>如果一台服务器托管了两个及以上主机名或域名的Web网站，当收到请求时就需要弄清究竟访问哪个域名了。因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。</p>
<h2 id="通信数据转发程序：代理、网关、隧道"><a href="#通信数据转发程序：代理、网关、隧道" class="headerlink" title="通信数据转发程序：代理、网关、隧道"></a>通信数据转发程序：代理、网关、隧道</h2><p>HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关、隧道。他们可以配合服务器工作。这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理是一种转发功能的应用程序，他扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发客户端。<br><strong>代理不会改变请求URI，会直接发送给前方持有资源的目标服务器。</strong><br><strong>持有资源实体的服务器被称为源服务器，从源服务器返回的响应后经过代理服务器后再传给客户端。</strong><br>在HTTP通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，<strong>需要附加 Via首部字段以标记出经过的主机信息</strong>。<br><em>使用代理服务器的理由：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的等等。</em><br>代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。</p>
<ol>
<li>缓存代理<br>代理转发响应时，缓存代理会预先将资源的副本保存在代理服务器上。<br>当代理服务器再次接收到相同的请求时，就可以不用从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。可以避免多次从源服务器转发资源。客户端可以就近从缓存服务器获取资源，源服务器也不必多次处理相同的请求。</li>
<li>透明代理<br>转发请求或响应时，不对报文加以任何加工的代理类型被称为透明代理。反之，对报文内容进行加工的代理被称为非透明代理。</li>
</ol>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关是转发其他服务器通信数据的服务器，（功能和代理十分相似）接收从客户端发来的请求时，他就像自己拥有资源的源服务器一样对请求进行处理。网关能使通信线路上的服务器提供非HTTP协议服务。<br>利用网关可以提高通信的安全性，因为可以在客户端和服务器之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。</p>
<h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>隧道可按要求建立起一条与其他服务器的通信线路，并使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。<br>隧道本身不会解析HTTP请求，请求保持原样传给服务器。隧道会在通信双方断开连接时结束。<br>通过隧道的中转，可以和远距离服务器安全通信。</p>
<h2 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h2><p>缓存指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可以减少对源服务器的访问，节省了通信流量和时间。<br>缓存服务器时代理服务器的一种，当代理服务器转发返回的响应时，会保存一部分资源的副本。</p>
<ol>
<li>缓存的有效期限<br>当源服务器上的资源更新时，如果还是使用不变的缓存，就换演变成返回更新前旧的资源。<br>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器会再次从源服务器获取资源。</li>
<li>客户端的缓存<br>缓存不仅可以存在与缓存服务器内，还可以存在于客户端浏览器中。<br>浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从磁盘内读取。<br>和缓存服务器相同，当判定缓存过期后，会向源服务器确认资源的有效性。</li>
</ol>
<h1 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h1><h2 id="HTTP报文首部"><a href="#HTTP报文首部" class="headerlink" title="HTTP报文首部"></a>HTTP报文首部</h2><p>HTTP协议的请求和响应报文中必定包含HTTP首部。<strong>首部内容为客户端和服务器分别处理请求和响应提供所需要的信息</strong>。<br>HTTP请求报文由方法、URI、HTTP版本、HTTP首部字段等功能组成。<br>HTTP响应报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段组成。 </p>
<h2 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h2><h3 id="首部字段传递重要信息"><a href="#首部字段传递重要信息" class="headerlink" title="首部字段传递重要信息"></a>首部字段传递重要信息</h3><p>能传递额外重要信息的作用，例如给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
<h3 id="HTTP首部字段结构"><a href="#HTTP首部字段结构" class="headerlink" title="HTTP首部字段结构"></a>HTTP首部字段结构</h3><p>HTTP首部字段是由<strong>首部字段名</strong>和<strong>字段值</strong>构成，中间用冒号“：”分隔。<br><strong>字段值对应单个HTTP首部字段可以有多个值</strong>。<br>若HTTP首部字段重复，有些浏览器会优先处理第一次出现的首部字段，而有些则会处理最后出现的首部字段。</p>
<h3 id="4种首部字段类型"><a href="#4种首部字段类型" class="headerlink" title="4种首部字段类型"></a>4种首部字段类型</h3><ol>
<li>通用首部字段</li>
<li>请求首部字段</li>
<li>响应首部字段</li>
<li>实体首部字段</li>
<li>非HTTP&#x2F;1.1 首部字段<br>在HTTP交互中使用的首部字段，除了RFC2616中定义的47种首部字段。还有Cookie、Set-Cookie和Content-Disposition等在其他RFC中定义的首部字段。这些非正式的首部字段统一归纳在RFC4229 HTTP Header Field Registrations 中。</li>
<li>End-to-end首部和Hop-by-hop<br> HTTP首部字段将定义成缓存代理和非缓存代理的行为，分为两种类型。<ol>
<li>端到端首部<br>分在此类别中的首部会转发给请求&#x2F;响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。</li>
<li>逐跳首部<br>分在此类别的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP&#x2F;1.1和之后的版本，如果要使用hop-by-hop首部，需提供Connection首部字段。<br>除下面的逐跳首部字段，其他都属于端到端首部。<br>connection<br>Keep-Alive<br>Proxy-Authenticate<br>Proxy-Authorization<br>Trailer<br>TE<br>Transfer-Encoding<br>Upgrade</li>
</ol>
</li>
</ol>
<h2 id="HTTP-x2F-1-1-通用首部字段"><a href="#HTTP-x2F-1-1-通用首部字段" class="headerlink" title="HTTP&#x2F;1.1 通用首部字段"></a>HTTP&#x2F;1.1 通用首部字段</h2><p>是响应报文和请求报文都会使用的首部。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>能够操作缓存的工作机制。<br><img src="/2023-03-29-19-47-45.png"><br>多个指令之间通过“，”分隔，首部字段Cache-Control的指令可用于请求及响应时。</p>
<p>缓存请求指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>no-cache</td>
<td>无</td>
<td>强制向源服务器再次验证</td>
</tr>
<tr>
<td>no-store</td>
<td>无</td>
<td>不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td>max-age&#x3D;[秒]</td>
<td>必需</td>
<td>相应的最大Age值</td>
</tr>
<tr>
<td>max-stale（&#x3D;[秒]）</td>
<td>可省略</td>
<td>接收已过期的响应</td>
</tr>
<tr>
<td>min-fresh&#x3D;[秒]</td>
<td>必需</td>
<td>期望在指定时间内的响应仍有效</td>
</tr>
<tr>
<td>no-transform</td>
<td>无</td>
<td>代理不可更改的媒体类型</td>
</tr>
<tr>
<td>only-if-cached</td>
<td>无</td>
<td>从缓存获取资源</td>
</tr>
<tr>
<td>cache-extension</td>
<td>新指令标记</td>
<td></td>
</tr>
<tr>
<td>缓存响应指令</td>
<td></td>
<td></td>
</tr>
<tr>
<td>指令</td>
<td>参数</td>
<td>说明</td>
</tr>
<tr>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>public</td>
<td>无</td>
<td>可向任意方向提供响应的缓存</td>
</tr>
<tr>
<td>private</td>
<td>可省略</td>
<td>仅向特定用户返回响应</td>
</tr>
<tr>
<td>no-cache</td>
<td>可省略</td>
<td>缓存前必须先确认其有效性</td>
</tr>
<tr>
<td>no-store</td>
<td>无</td>
<td>不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td>no-transform</td>
<td>无</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td>must-revalidate</td>
<td>可缓存但必须再向源服务器确认</td>
<td></td>
</tr>
<tr>
<td>proxy-revalidate</td>
<td>无</td>
<td>要求中间缓存服务器对缓存的响应有效性再进行确认</td>
</tr>
<tr>
<td>max-age&#x3D;[秒]</td>
<td>必须</td>
<td>响应最大的Age值</td>
</tr>
<tr>
<td>s-maxage&#x3D;[秒]</td>
<td>必须</td>
<td>公共缓存服务器响应的最大Age值</td>
</tr>
<tr>
<td>cache-extension</td>
<td>-</td>
<td>新指令标记</td>
</tr>
</tbody></table>
<h4 id="表示能否缓存的指令"><a href="#表示能否缓存的指令" class="headerlink" title="表示能否缓存的指令"></a>表示能否缓存的指令</h4><ol>
<li>public<br>当指定使用public指令时，则明确表明其他用户也可以利用缓存。</li>
<li>private<br>响应只以特定的用户作为对象，这与public指令的行为相反。<br>缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。</li>
<li>no-cache指令<br>防止从缓存中返回过期的资源。<br>客户端发送的请求中如果包含no-cache，则表示客户端将不会接收缓存过的响应。于是，缓存服务器必须把请求转发给源服务器。<br>如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存。源服务器以后将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存。<br>由服务器返回的响应中，若报文首部字段Cache-Control中对no-cache字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，不能使用缓存。<strong>无参数值的首部字段客户端可以缓存</strong>。 只能在<strong>响应</strong>指令中指定该参数</li>
</ol>
<h4 id="控制可执行缓存的对象的指令"><a href="#控制可执行缓存的对象的指令" class="headerlink" title="控制可执行缓存的对象的指令"></a>控制可执行缓存的对象的指令</h4><ol>
<li>no-store指令<br>使用该指令时暗示请求（和对应的响应）或响应中包含机密信息。<br>因此不能在本地存储请求或响应的任一部分</li>
</ol>
<h4 id="指定缓存期限和认证的指令"><a href="#指定缓存期限和认证的指令" class="headerlink" title="指定缓存期限和认证的指令"></a>指定缓存期限和认证的指令</h4><ol>
<li>s-maxage指令<br>和max-age指令的功能相同，他们的不同点是s-maxage指令只适用于供多位用户使用的公共缓存服务器（代理）。也就是说，对于同一用户重复返回响应的服务器来说，这个指令没有任何作用。<br>使用s-maxage指令后，则直接忽略对Expires首部字段及max-age指令的处理。</li>
<li>max-age指令<br>当客户端发送的请求中包含max-age指令时，如果判定缓存资源的时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。如果指定max-age值为0，那么缓存服务器通常需要将请求转发给源服务器。<br>当服务器返回的响应中包含max-age指令时，缓存服务器将不对资源的有效性再次确认，而max-age值代表资源保存为缓存的最长时间。<br>HTTP&#x2F;1.1当缓存服务器遇到同时存在Expires首部字段的情况时，优先处理max-age指令，而忽略掉Expires首部字段。而HTTP&#x2F;1.0则相反。</li>
<li>min-fresh指令<br>min-fresh指令要求响应至少在保险时间内,要求缓存服务器返回至少还未过指定时间的缓存资源。<br>比如，当指定min-fresh为60秒后 ，在这60秒以内如果有超过有效期限的资源都无法作为响应返回。</li>
<li>max-stale<br>使用max-stale可指示缓存资源，即使过期也照常接收。<br>如果指令未指定参数值，无论过多久，客户端都会接收响应；如果指令中指定了具体数值，那么即使过期，只要仍处于max-stale指定的时间内，仍旧会被客户端接收。</li>
<li>only-if-cached<br>表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码504 Gateway Timeout。</li>
<li>must-revalidate<br>代理会向源服务器再次验证即将返回的响应缓存是否仍然有效。<br>若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条504状态码。<br>另外，使用must-revalidate指令会忽略请求的max-stale指令(即使已经在首部使用了max-stale，也不会有效果)</li>
<li>proxy-revalidate指令<br>要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</li>
<li>no-transform指令<br>使用该指令规定无论在请求还是在响应中，缓存都不能改变实体主体的媒体类型。</li>
</ol>
<h4 id="Cache-control扩展"><a href="#Cache-control扩展" class="headerlink" title="Cache-control扩展"></a>Cache-control扩展</h4><p>cache-extension token<br>通过cache-extension标记（token），可以扩展cache-control首部字段内的指令。</p>
<h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>Connection首部字段有以下两个作用。</p>
<ol>
<li>控制不再转发给代理的首部字段。<br><img src="/2023-04-03-20-32-58.png"><br>在客户端发送请求和服务器返回的响应内，可以使用Connection首部字段，可控制不再转发给代理的首部字段。</li>
<li>管理持久连接。<br>HTTP&#x2F;1.1版本默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当客户端向明确断开连接时，则指定Connection字段的值为close。<br>HTTP&#x2F;1.1之前的版本默认都是非持久连接。为此想在旧版本维持连接，需要指定connection首部字段值为keep-alive。<br>客户端发送请求给服务器，服务器会加上首部字段keep-alive。</li>
</ol>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>首部字段Date表明创建HTTP报文的日期和时间。<br>在RFC1123中规定的日期时间的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date:Tue, 03 Jul 2012 21:25:59 GMT</span><br></pre></td></tr></table></figure>
<p>RFC850中的格式，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date:Tue, 03-Jul-12 21:25:59 GMT</span><br></pre></td></tr></table></figure>
<p>除此之外，还有一种格式。它与C标准库内的asctime（）函数的输出格式一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date:Tue Jul 03 21:25:59 2012</span><br></pre></td></tr></table></figure>
<h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p>该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不反回缓存的资源。<br>通常发送的请求会同时包含下面两个首部字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure>
<h3 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h3><p>会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在HTTP&#x2F;1.1版本分块传输编码时。</p>
<h3 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h3><p>规定了传输报文主体时采用的编码方式。<br>HTTP&#x2F;1.1的传输编码方式仅对分块传输编码有效。</p>
<h3 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h3><p>用于检测HTTP协议及其他协议是否可以使用更高版本的通信，其参数值可以用来指定一个完全不同的通信协议。<br>首部字段Upgrade指定的值为TLS&#x2F;1.0。请注意此处两个字段首部字段的对应关系，Connection的值被指定为Upgrade。Upgrade首部字段产生作用的Upgrade对象仅限于客户端和邻接服务器之间。因此，使用首部字段Upgrade时，还需要额外指定Connection：Upgrade。<br>对于附有首部字段Upgrade的请求，服务器可用101Switching Protocols状态码作为响应返回。</p>
<h3 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h3><p>该字段为了追踪客户端与服务器之间的请求和响应报文的传输路径。<br>报文经过代理或网关时，会在首部字段Via中附加该服务器的信息，然后再进行转发。这个做法和traceroute及电子邮件的Received首部的工作机制类似。<br>首部字段Via不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。<br>各个代理服务器会往Via首部添加自身服务器的信息。在Via首部附加服务器信息，也可以增加一个新的Via首部写入服务器信息。<br>Via是为了追踪传输路径，所以经常会和TRACE方法一起使用。比如：<br>代理服务器接收到由TRACE方法发送过来的请求（其中Max-Forwards：0）时，代理服务器就不能转发该请求了。这种情况下，代理服务器会将自身的信息附加到Via首部后，返回该请求的响应。</p>
<h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h3><p>该首部通常会告知用户一些与缓存相关的问题的警告。<br>Warning首部的格式如下。最后的日期可以忽略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: [警告码] [警告的主机：端口号] &quot;[警告内容]&quot; ([日期时间])</span><br></pre></td></tr></table></figure>
<p>HTTP&#x2F;1.1中定义了7种警告。</p>
<h2 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h2><p>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用以补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p>
<h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h3><p><img src="/2023-04-08-21-44-24.png"><br>该首部可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用type&#x2F;subtype这种形式，一次指定多种媒体类型。<br>比如，如果浏览器如果不支持PNG图片的显示，那么Accept就不指定image&#x2F;png,而可以指定处理的其他图片类型。<br>若想给显得媒体类型增加优先级，则使用“q&#x3D;”来额外表示权重值，用分号（；）分隔。权重值的范围是0-1（可精确到小数点后3位0）。不指定权重值时，默认q&#x3D;1.0。<br>当服务器提供多种内容时，优先返回权重值最高的媒体类型。</p>
<h3 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h3><p>可用来通知服务器，用户代理支持的支持的字符集，及字符集的相对优先顺序。另外可一次性指定多种字符集，并可用权重q来表示相对优先级。<br>该首部字段用于内容协商机制的服务器驱动协商。</p>
<h3 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h3><p>用来告知服务器，用户代理支持的内容编码及优先级顺序，可一次性指定多种内容编码。采用权重q表示相对优先级。也可用星号（*）作为通配符，指定任意的编码格式。</p>
<h3 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h3><p><img src="/2023-04-08-22-45-24.png"><br>用来告知服务器，用户代理能够处理的自然语言集（指中文或英文等），可一次指定多种，以及其优先级。使用权重值q来表示相对优先级 </p>
<h3 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h3><p><img src="/2023-04-08-22-45-32.png"><br>用来告知服务器，用户代理的认证信息（证书值）。通常通过服务器认证的用户代理会在接收到返回的401状态码响应后，把首部字段Authorization加入到请求中。共用缓存在接收到含有Authorization首部字段的请求时的操作处理会略有差异。</p>
<h3 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h3><p>用来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望做出回应而发生错误时，会返回状态码417 Expectation Failed。<br><strong>客户端可以利用该首部字段，写明所期望的扩展。虽然HTTP&#x2F;1.1规范只定义了100-continue。</strong><br>等待状态码100响应的客户端在发生请求时，需要指定Expect：100-continue。</p>
<h3 id="From"><a href="#From" class="headerlink" title="From"></a>From</h3><p>用来告知服务器使用用户代理的，用户的电子邮件地址。是为了显示搜索引擎等用户处理的负责人的电子邮件的联系方式。使用代理时，尽可能包含From首部字段（但可能因为代理不同，将电子邮件地址记录在User-Agent首部字段内）。</p>
<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p><img src="/2023-04-08-22-53-47.png"><br>虚拟主机运行在同一个IP上，可使用Host区分。<br>告知服务器，请求的资源所处的互联网主机名和端口号。Host首部字段在HTTP&#x2F;1.1规范内必须被包含在请求内（唯一）。<br>请求被发送至服务器时，请求中的主机名会用IP地址直接替换解决。如果相同的IP地址下部署运行多个域名，服务器无法理解究竟是哪个域名对应的请求，因此需要Host明确指出请求的主机名。如果服务器未设定主机名，那么直接发送一个空值。</p>
<h3 id="If-xxx"><a href="#If-xxx" class="headerlink" title="If-xxx"></a>If-xxx</h3><p>形如If-xxx的请求首部字段，都可称作条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求<br><img src="/2023-04-09-20-50-06.png"><br>首部字段If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记值（ETag）。这时的服务器无法使用弱ETag值。服务器会比对If-Match的字段值和资源的ETag值，仅当两者相同时才会执行请求。反之则返回状态码412 Precondition Failed的响应。<br>还可以使用“*”指定If-Match的字段值。这种情况下服务器将会忽略ETag的值，只要资源存在就会处理请求。</p>
<h3 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h3><p><img src="/2023-04-09-21-12-31.png"><br>如果在字段指定的日期后，资源发生了更新，服务器会接受请求并返回最近一次的更新时间。如果没有发生过更新，则返回状态码304 Not Modified的响应。<br>用于确认代理或客户端拥有的本地资源的有效性，并获取资源的更新日期。</p>
<h3 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h3><p><img src="/2023-04-09-21-12-45.png"><br>只有在该首部的字段值与ETag值不一样时，可处理该请求，与If-Match首部字段作用相反。<br>在GET或HEAD方法中使用该首部字段可获取最新的资源。因此，这与使用首部字段If-Modified-Since时有些类似。</p>
<h3 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h3><p><img src="/2023-04-09-21-30-54.png"><br>If-Range属于附带条件之一。他告知服务器若指定的If-Range字段值和请求资源的ETag或时间相同时，则作为<strong>范围请求</strong>处理。反之则返回<strong>全体</strong>资源。<br><img src="/2023-04-09-21-35-10.png"><br>服务器端的资源如果更新，那么范围请求作为前提是无效的。这时服务器会暂且以状态码412 Precondition Failed作为响应返回，目的是催促客户端再次发送请求。如果不使用首部字段If-Range则需要两次处理。</p>
<h3 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h3><p>与If-Modified-Since作用相反，告知服务器，指定的请求资源在字段值内指定的日期之后未发生更新，才能处理请求，如果之后资源发生了更新则返回状态码412 Precondition Failed。</p>
<h3 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h3><p>通过TRACE或OPTIONS方法，发送包含首部字段Max-Forwards的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求时，会将Max-Forwards值减1后重新赋值。当服务器收到值为0的请求时，则不再转发，而是直接返回。<br>途中，如果服务器由于某些原因导致请求转发失败，客户端就接收不到服务器返回的响应。可以运用Max-Forwards，针对上述问题的原因进行调查。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://iwefwkg.github.io/2023/03/13/%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mxm">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/13/%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-03-13 19:29:29" itemprop="dateCreated datePublished" datetime="2023-03-13T19:29:29+08:00">2023-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-03-15 08:19:42" itemprop="dateModified" datetime="2023-03-15T08:19:42+08:00">2023-03-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hash-table"><a href="#Hash-table" class="headerlink" title="Hash table"></a>Hash table</h1><h2 id="leetcode-1-两数之和"><a href="#leetcode-1-两数之和" class="headerlink" title="leetcode 1(两数之和)"></a>leetcode 1(两数之和)</h2><p>利用哈希表，将原数组的值作为哈希表的地址，把原数组的地址作为数值存放在哈希表中。</p>
<h2 id="leetcode-3"><a href="#leetcode-3" class="headerlink" title="leetcode 3"></a>leetcode 3</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://iwefwkg.github.io/2023/03/12/operating-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mxm">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/12/operating-system/" class="post-title-link" itemprop="url">operating system</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-03-12 22:01:02" itemprop="dateCreated datePublished" datetime="2023-03-12T22:01:02+08:00">2023-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-04-11 14:55:52" itemprop="dateModified" datetime="2023-04-11T14:55:52+08:00">2023-04-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>此科目主要关注发生在内核内部的事情，还有用户程序和内核之间的接口，以及内核内部的软件结构。以及应用程序与内核的交互，和相关接口定义。</strong></p>
<h1 id="lecture-1-introduction-and-example"><a href="#lecture-1-introduction-and-example" class="headerlink" title="lecture 1-introduction and example"></a>lecture 1-introduction and example</h1><h2 id="操作系统的共同目标"><a href="#操作系统的共同目标" class="headerlink" title="操作系统的共同目标"></a>操作系统的共同目标</h2><ol>
<li><em><strong>abstract hardware</strong></em> 硬件的抽象<br><strong>Abstraction</strong> ，<em>将复杂问题简单化，使程序员专注在重要的部分。抽象就是把一个问题或模型，以不同的规则和方法得到不同的解（求解方法和解本身就是抽象层），这些不同的抽象层可以组合并还原成问题或模型本身。</em><br>从计算机的cpu，硬盘，内存等一个低水平，到高水平层次的抽象化，可以是我们使用应用程序，如为了方便和移植性而产生的进程或文件系统。</li>
<li><em><strong>multiplex</strong></em> 应用程序对硬件的多路复用<br>同时运用多个应用程序并且不会相互干扰</li>
<li><em><strong>Isolation</strong></em> 隔离性<br>不同的活动不应该互相干涉。</li>
<li><em><strong>sharing</strong></em><br>在需要时，可以相互干涉，或者在需要干涉来交互或协作。</li>
<li><em><strong>security or permission system</strong></em> 安全系统或权限系统<br>能控制文件或应用的分享与保密</li>
<li><em><strong>performance</strong></em> 性能<br>能够帮助应用程序获得良好的硬件性能</li>
<li><em><strong>range of uses</strong></em> 各种不同用途<br>同一个操作系统能够支持使用各种不同的应用与用途</li>
</ol>
<h2 id="操作系统的组成"><a href="#操作系统的组成" class="headerlink" title="操作系统的组成"></a>操作系统的组成</h2><p><img src="/2023-03-16-17-13-47.png"><br>硬件位于底层，应用程序位于顶层。应用程序的这个地方称作用户空间（<em><strong>Userspace</strong></em>）<br><strong>内核</strong>（<em><strong>KERNEL</strong></em>）一直处于运行中，是计算机资源的守护者。在开机时第一个启动，只有一个内核来管理数据。以帮助管理顶层进程，也意味着大量数据结构帮助访问。帮助管理用户程序所需要使用的不同类型的硬件。<br><strong>进程</strong>（<em>运行的程序</em>）<br>内核也内置了很多服务，例如：  </p>
<ol>
<li>FS 文件系统（实现了文件名，文件内容和目录之类的；并将文件存在磁盘中）应用程序访问内核中的文件，然后文件系统访问磁盘。</li>
<li>process  对进程的管理，每个进程它有自己的内存，共享cpu时间。内核将进程作为内核服务进行管理。</li>
<li>memory 内核管理内存的分配，不同的进程需要不同数量的内存，内核复用、划分内存，为所用不同的进程分配内存。</li>
<li>访问控制，进程想要读取，使用资源时，是由内核决定的。可以决定进程是否能够读取硬盘或使用内存。</li>
</ol>
<h2 id="API-KERNEL-内核接口"><a href="#API-KERNEL-内核接口" class="headerlink" title="API KERNEL 内核接口"></a>API KERNEL 内核接口</h2><p>应用程序通过系统调用访问内核（与程序使用的函数调用类似），实际上是跳入内核，并在执行内核中实现系统调用。<br>内核可以获得系统调用的参数，并执行一些实现系统调用的内核代码。<br><strong>系统调用是操作系统提供服务的接口。</strong><br><strong>传递一个整数，比如文件描述符和进程id，作为系统调用的参数传递。</strong></p>
<h2 id="Unix系统调用简介"><a href="#Unix系统调用简介" class="headerlink" title="Unix系统调用简介"></a>Unix系统调用简介</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p><em>程序是静态的，进程是动态的。程序是有序代码的集合，进程是程序的执行。</em><br>作用就是索引到内核中一个维护状态的表中，内核为每个进程记住一个表，表中通过文件描述符进行索引（为每个正在运行的进程用文件描述符提供索引），这张表告诉内核每个文件描述符引用的是什么。<br>每个进程都有自己的文件描述符空间。因此，在运行两个不同的进程前，两个不同的程序都会打开一个文件，它们可能会得到相同的文件描述符编号，但是因为<strong>内核为每个进程维护单独的文件描述符</strong>，所以相同的文件描述符在不同的进程中可能引起不同的文件。</p>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>通常称作命令行接口，相对更图形化的用户界面。shell是unix的一种最传统最基本的接口，对unix系统的系统管理提供了很多实用程序，来处理文件，开发程序，以及编写脚本来完成这些事。<br>Shell指令的本质：<br>例如mkdir指令，实际上它是存在于这台计算机上的一个可执行文件，一个程序，输入mkdir指令时会运行这个程序，来完成一些功能。</p>
<p>在一些pwn题中，拿到靶机的shell后会发现能够使用的指令很少，应该就是因为靶机削减了一些不必要的的指令程序。</p>
<ol>
<li>fork<br>创建一个调用进程的指令和数据的内存的复制，使用之后会有两个使用相同内存的进程，两个进程都有自己不同的地址空间，它们都认为自己的内存从0开始向上增长，但是其实是不同的内存。<br>子进程的文件描述符表是复制的，如果父进程打开一些文件，子进程也会看到一组相同的文件描述符。<br>fork系统调用在两个进程中都会返回，原始进程中fork返回进程id，它是一个<strong>大于零的整数</strong>，<strong>新进程中fork返回0</strong>。<br>在调用fork后，两个进程几乎会同时进行，所以它们产生的输出是交错的。<br>fork创建了一个新进程，<strong>当我们在shell中运行东西时，shell实际上创建了一个新进程来运行你输入的指令，但它需要在其中运行命令。</strong>。如果输入ls，需要shell fork 创建一个新进程运行ls，但这个新进程需要一些方法，来实际运行ls程序中的指令。</li>
<li>exec<br>exec是一个系统调用，<strong>使用指定的文件中读取的指令替换调用的进程</strong>。从文件中加载指令，覆盖当前进程，丢弃当前内存，然后执行这些指令，用新程序覆盖这个程序的上下文和内存空间。保留了当前文件描述符表，之前的文件描述符代表什么，在新程序也引用相同的东西。</li>
</ol>
<p><img src="/2023-04-06-22-41-31.png"></p>
<p>exec在第12行，使操作系统从echo文件中加载指令，在当前进程中，替换当前进程的内存，然后开始执行那些指令。并且可以传递参数，echo exec允许传递一组命令行参数（它只是c语言中的一组字符指针）。<br>第10行设置了一组字符指针，本质上是字符串，并且将该数组初始化为包含字符串 “echo this is echo”。这相当于在命令行允许echo，使用参数，this is “echo”（参数）。每个在双引号中的字符串实际上是一个指向内存中包含这些字节的指针，最后的0是值为0的指针，相当于空指针，内核遍历整个数组，直到找到该空指针。<br>在命令行直接允许exec，输出“this is echo”。即使我们运行的是exec程序，该程序说，做的是调用exec系统调用，将其自身换为echo，所以实际上就是echo程序，产生这个输出。<br>原始的exec不会返回，因为echo完全替换了当前进程内存，没有什么东西让exec返回，因为它读取文件中的指令，并执行他们。只有发生错误的时候,在内核不能运行文件时返回，导致操作系统无法运行该程序，比如：程序根本不存在，exec找不到名为echo的文件，exec将返回-1，表示出现错误。<br>3. forkexec<br><img src="/2023-04-07-22-58-04.png"><br>程序使用文件中的另一个程序替换自己的过程，但实际上我们在shell中运行东西，例如：echo 或者ls，我们不希望替换掉shell，shell只是调用exec，因为那样echo会替换掉shell，那样就全部结束了，所以shell要做的是fork，然后用子进程调用exec。对于父进程，重新获得了控制权，因为当fork返回时，在父进程返回一个大于零的值，所以父进程继续执行下面指令。这就是unix惯用程序，<strong>想要运行一个程序，并重新获得控制权，要做的就是调用fork，然后子进程调用exec</strong><br>第20行，进程等待fork创建的子进程，当我们在命令行运行一条命令，在它重新输出提示符（$）等待我输入更多之前，我们希望shell等待。（等待是偶然的情况，父进程和子进程输出相交错，子进程调用了exec，需要访问磁盘丢弃旧内存分配新内存等机器指令），所以wait系统调用运行进程，等待子进程返回。第17行推出参数为1，系统将1从退出的子进程传递给第20行的wait。所以wait将状态变量地址（&amp;status）传递给内核，内核使用子进程退出的参数填充该地址。wait会返回子进程的id，在有多个子进程时，可以通过wait返回区分是哪一个子进程退出了。<br>unix约定，如果一个程序成功退出，退出码是0，并且不会执行下面的failed和exit 1。但是在第17行中约定这里的退出码是1,如果出现错误时，exec返回原来的调用函数继续执行下面的语句，并且返回1。如果没有子进程，wait会直接返回-1错误。<br>复制内存是指，程序在编译之后会变成内存中的一些机器指令，驻留在内存中，只是内存中的一些字节，可以复制到其他地方，可以通过设置虚拟内存映射使子进程和父进程看起来一样。<br>4. redirect IO重定向</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &gt; out</span><br></pre></td></tr></table></figure>
<p>此时ls没有任何输出，out内包含一些数据。<br>执行<strong>cat命令读取文件并显示其中的内容</strong>，此时输出和ls的输出是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat out </span><br></pre></td></tr></table></figure>
<p>grep x命令通过模式搜索，它会搜索包含x的输入行，我们也可以告诉shell把grep的输入重定向到out文件,用来查找保存ls结果中的x实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep x &lt; out</span><br></pre></td></tr></table></figure>
<p>只是对echo的输出重定向，所以运行redirect，不会产生输出，只会运行echo并把它的输出定向到output.txt文件。echo输出到文件描述符1，就会写入到output.txt，但echo并不知道发生了重定向，只有shell知道发生了重定向。<br><img src="/2023-04-08-14-47-23.png"><br>通常，大多数程序使用文件描述符1作为输出。在子进程，shell将子进程的文件描述符1修改为指向输出文件，同时保留了父进程shell的文件描述符1不变。这种在子进程修改文件描述符的方法，是unix的常用方法，重定向运行的命令的输入输出，但是不影响调用程序的输入输出，因为我们不想重定向shell的输出。<br>第15行关闭文件描述符1的原因，我们想把输出文件描述符1，指向别的东西（<strong>子进程不能直接使用父进程的1，因为shell使用1连接控制台</strong>）。然后在第16行使用open，因为open调用返回没有被当前程序使用的最小的文件描述符，而我们关闭了1，0仍然连接到控制台。</p>
<h1 id="Lecture-3-Operating-system-Organization"><a href="#Lecture-3-Operating-system-Organization" class="headerlink" title="Lecture 3 Operating system Organization"></a>Lecture 3 Operating system Organization</h1><h2 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h2><p>kernel mode 和user mode 是内核或操作系统与用户隔离的一种方式</p>
<h2 id="kernel-mode-x2F-user-mode"><a href="#kernel-mode-x2F-user-mode" class="headerlink" title="kernel mode&#x2F;user mode"></a>kernel mode&#x2F;user mode</h2><h2 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h2><h2 id="xv6代码"><a href="#xv6代码" class="headerlink" title="xv6代码"></a>xv6代码</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mxm</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
